Cookies are small pieces of data that a server sends to a user’s browser, and the browser automatically stores them and sends them back to the same server with every future request. This allows the server to maintain state in the otherwise stateless HTTP protocol. Cookies are commonly used for session management (like keeping users logged in), personalization (storing preferences such as theme or language), and tracking or analytics (recording user behavior). Each cookie includes attributes like expiration time, security flags (secure, httpOnly), path rules, and sameSite protections), all of which define how the cookie behaves and how secure it is. Cookies can be session-based or persistent and are always transmitted through HTTP headers (Set-Cookie and Cookie). In Next.js route handlers, cookies can be read or set using built‑in APIs, allowing the backend to authenticate users, store preferences, and maintain user-specific data. Understanding cookies is essential because they form the foundation of login systems, session handling, personalization features, and many other backend operations in modern web applications.

Caching in Next.js route handlers means the server saves the result of a GET request and reuses it instead of running backend logic on every request. It is mainly used with GET because GET requests only read data and do not change anything, making them safe to cache. In this code, force-static tells Next.js to treat the route as static, and revalidate = 10 tells it to regenerate the response every 10 seconds. The GET function returns the current time, but because of caching, users will see the same time for 10 seconds before it updates. This improves performance, reduces server work, and helps the app scale. This is a backend optimization that controls when server code runs, not a frontend feature.

npm run dev starts a development server that helps developers by auto-refreshing code, showing detailed errors, and allowing fast changes, but it is slow and not optimized. npm run build prepares the application for production by optimizing and compiling the code but does not start a server. npm run start runs the optimized production server created by the build step and is meant for real users. We use different commands because development prioritizes flexibility and debugging, while production prioritizes speed, security, and stability


Middleware
Middleware in Next.js is server-side code that runs automatically whenever a user makes a request to your app. It runs before any page or API logic and allows the server to decide what should happen with the request. When someone tries to open /profile, the server checks the URL inside middleware. If the condition matches, the server immediately sends a redirect response to the browser, telling it to go to /hello. The browser then follows that instruction without ever loading the original page. This is backend logic because it works at the HTTP request–response level, not inside React or the browser. Middleware exists to make early decisions like access control, redirects, and security checks before rendering happens.
Next request
Internally, NextRequest is Next.js’s structured representation of an incoming HTTP request. When a browser (or any client) sends a request, it is just raw network data: a URL string, headers, cookies, method, and possibly a body. NextRequest takes this raw HTTP data and parses it into a clean, readable object. It extracts things like the full URL, pathname, query parameters, headers, cookies, and method in a safe and consistent way. Instead of you manually decoding URLs, splitting strings, or parsing headers, NextRequest gives you a ready-to-use view of what the client is asking for.
Next Response
NextResponse, on the other hand, is Next.js’s structured way to build an outgoing HTTP response. Internally, it prepares everything a server response needs: a status code, headers, and a body. When you call NextResponse.redirect() or NextResponse.json(), Next.js automatically sets the correct HTTP status (like 302 for redirect or 200 for JSON), attaches required headers (like Location or Content-Type), serializes data when needed, and finalizes the response so it can be sent back over the network. Without this, you would have to manually remember which headers and status codes are required for each type of response.