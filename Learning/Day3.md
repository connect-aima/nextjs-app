Cookies are small pieces of data that a server sends to a user’s browser, and the browser automatically stores them and sends them back to the same server with every future request. This allows the server to maintain state in the otherwise stateless HTTP protocol. Cookies are commonly used for session management (like keeping users logged in), personalization (storing preferences such as theme or language), and tracking or analytics (recording user behavior). Each cookie includes attributes like expiration time, security flags (secure, httpOnly), path rules, and sameSite protections), all of which define how the cookie behaves and how secure it is. Cookies can be session-based or persistent and are always transmitted through HTTP headers (Set-Cookie and Cookie). In Next.js route handlers, cookies can be read or set using built‑in APIs, allowing the backend to authenticate users, store preferences, and maintain user-specific data. Understanding cookies is essential because they form the foundation of login systems, session handling, personalization features, and many other backend operations in modern web applications.

Caching in Next.js route handlers means the server saves the result of a GET request and reuses it instead of running backend logic on every request. It is mainly used with GET because GET requests only read data and do not change anything, making them safe to cache. In this code, force-static tells Next.js to treat the route as static, and revalidate = 10 tells it to regenerate the response every 10 seconds. The GET function returns the current time, but because of caching, users will see the same time for 10 seconds before it updates. This improves performance, reduces server work, and helps the app scale. This is a backend optimization that controls when server code runs, not a frontend feature.

npm run dev starts a development server that helps developers by auto-refreshing code, showing detailed errors, and allowing fast changes, but it is slow and not optimized. npm run build prepares the application for production by optimizing and compiling the code but does not start a server. npm run start runs the optimized production server created by the build step and is meant for real users. We use different commands because development prioritizes flexibility and debugging, while production prioritizes speed, security, and stability