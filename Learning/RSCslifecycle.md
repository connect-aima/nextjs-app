When you build an app with **Next.js using React Server Components (RSCs)**, the idea is that your page is not created entirely in the browser anymore. Instead, the **server does most of the heavy work**, and the browser mainly displays the result and adds interactivity. Three things are involved in this process: the **browser**, **Next.js running on the server**, and **React**. The browser asks for a page, Next.js decides what code should run, and React renders the UI in a smart way.

When a user opens a page for the **first time**, the browser sends a request for a specific URL. Next.js looks at your `app` folder and finds the matching route, which is usually a **server component by default**. React then runs this server component and all of its child server components on the server. During this step, React can safely fetch data from databases or APIs because this code never runs in the browser. Instead of directly producing HTML, React converts the result into a **special JSON-like format called the RSC payload**. This payload is not the UI itself; it is more like detailed instructions that explain what the UI should look like and what data it should use.

If React encounters a **Suspense boundary** while rendering, it temporarily pauses that part of the UI and sends a placeholder instead. This allows the rest of the page to appear quickly without waiting for slow data. At the same time, React also prepares instructions for any **client components**, which are the parts of your app that will later handle clicks, state, and user interactions. Next.js then takes the RSC payload and these client instructions and turns them into **HTML on the server**. This HTML is streamed to the browser immediately, so the user can see the page very quickly, even though it is not interactive yet.

Along with the HTML, Next.js also streams the **RSC payload** to the browser. When the browser receives this data, React uses it to reconstruct the full component tree. Once all the required JavaScript for client components is loaded, **hydration** happens. Hydration is the process where React attaches event listeners and state logic to the existing HTML, transforming the page from a static display into a fully interactive application. At this point, the user can click buttons, type into inputs, and interact with the UI normally.

When the page later **updates**, such as when navigating to another route or refreshing part of the UI, the process is different from the initial load. The browser requests new data, Next.js again renders the relevant server components, and React produces a **new RSC payload**. This time, Next.js does not generate new HTML. Instead, it streams only the updated JSON payload back to the browser. React then **reconciles** this new output with the existing UI, updating only the parts that changed while keeping things like scroll position, input values, and user interactions intact. This makes updates feel smooth and fast.

On the server, Next.js can render pages in **three different ways**. With **static rendering**, the page is generated once at build time and reused for every user, making it extremely fast. This is ideal for content that rarely changes, like blogs or documentation. With **dynamic rendering**, the page is rendered on every request, which is useful for personalized or authentication-based content such as dashboards. With **streaming rendering**, the server sends parts of the UI as soon as they are ready, allowing users to see content gradually instead of waiting for everything to load at once.

In simple terms, the rendering lifecycle in Next.js with RSCs works like this: the **server prepares the structure and data**, sends smart instructions to the browser, and the **browser completes the job by making the page interactive**. This approach improves performance, keeps sensitive logic on the server, and provides a smoother user experience without constantly reloading the page.
